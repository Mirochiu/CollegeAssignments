//------------------------------------------------------------------------------
//	撰寫人: 邱永祥
//	建立日期: 不明
//	最後修改: 2006-11-22 07:52:09 
//------------------------------------------------------------------------------
//	設計理念：直觀、簡單
//	
// 基於這個設計理念，所以我按照課本所分割的功能，逐一製作成為一個個函式， 
// 除subkey產生的部份外，大都完整的區分各自的工作。關於資料結構的定義，則 
// 是使用2維陣列，每個bit就儲存一個元素，我是以char型態作為儲存資料的單位 
// ，這麼作是為了撰寫的安全性(safety)與可靠性(reliability)，因為我本身幾 
// 乎沒有操縱bit的經驗，且像這樣的程式碼，我覺得還要有個照應後再進行改變 
// ，所以完全參照課本表格與資料大小進行各個部份的資料結構定義。至於演算法 
// ，則是使用以前coding的一些技巧，將課本中所陳述的語句轉化成程式碼，大抵 
// 是沒在考慮程式效率的方式，也是如此才能達成『簡單』兩字的目的。
//------------------------------------------------------------------------------
#ifndef DES_H
#define DES_H

#include <stdlib.h>		// malloc, free

#include "des_tables.h"
#include "des_types.h"

//------------------------------------------------------------------------------
//	參考IP表的資料，將所需的bit抓進newdat，IP是8x8的二維矩陣。
//	適用於：InitialPermutation , Inverse Initial Permutation
//	64 bits -> 64 bits
//------------------------------------------------------------------------------
dat64perbit InitialPermutation (dat64perbit dat, const int IP[8][8]) {
	dat64perbit newdat;
	int x, y, opos;
	for ( x=0 ; x <8 ; x++ )
		for ( y=0 ; y <8 ; y ++ ) {
			opos = IP[y][x]-1;
			newdat.bit[y][x] = dat.bit[opos/8][opos%8];
		}
	return newdat;
}
//------------------------------------------------------------------------------
//	參考E表的資料，然後從dat中取出所需的bit放入新資料中。
//	half = 0，代表取左邊32bit產生48bits；half = 1，代表右邊取32bit產生48bits
//	32=4*8 =>> 8*6=48
//	這個函式省略了從64bits對應到32bits結構中，直接用half參數控制擷取。
//------------------------------------------------------------------------------
dat48perbit ExpansionPermutation (dat64perbit dat, int half, const int E[8][6]) {
	dat48perbit newdat;
	int x, y, opos;
	for ( x=0 ; x<6 ; x++ )
		for ( y=0 ; y<8 ; y++ ) {
			opos = E[y][x] + (half?31:-1);	// 第32個bit以後是右邊
			newdat.bit[y][x] = dat.bit[opos/8][opos%8];
				// 等號右邊是依據原本資料的寬,而不是新資料寬
		}
	return newdat;
}
//------------------------------------------------------------------------------
// 48bits的data與key作xor運算
//------------------------------------------------------------------------------
//	因為都是0 xor 0 所以其他bit不會影響到結果
//------------------------------------------------------------------------------
dat48perbit xor48bits (dat48perbit dat, key48perbit key) {
	int i;
	for (i=0 ; i<48 ; i++ )
		dat.bit[i/6][i%6] ^= key.bit[i/8][i%8];
			// data=>(y=8,x=6), key=>(y=6,x=8)
	return dat;
}
//------------------------------------------------------------------------------
//	S-box的8個6轉4循序運作
//	48 bits -> 32 bits
//------------------------------------------------------------------------------
//	錯誤修正: 分解資料沒有將資料右移，使輸出資料都相同。
//------------------------------------------------------------------------------
// * 程式碼解說一：
//		for ( i=1, col=0 ; i<5 ; i++ )
//			col |= (dat.bit[n][i]<<(4-i));	// 取中間的4位元到col中
//
// col 在一開始的時候會歸零，不歸零即可能含有垃圾資料，造成不正常執行。這個部 
// 份的程式碼實際上可以用一個長式子進行代換，只是我看到要進行陣列元素的加總， 
// 直接的就寫上迴圈了，如果看不懂就用下面的代換掉囉！
// col = dat.bit[n][1]<<3 + dat.bit[n][1]<<2 + dat.bit[n][1]<<1 + dat.bit[n][1];
//	
// * 程式碼解說二：
//		for ( m=3 ; m>=0 ; m-- ) {
//			bit = data & 0x01;
//			newdat.bit[n/2][m] = bit;
//			data>>=1;
//		}
//
// 這個函式會使用反轉迴圈，是由於要分解資料data，將資料的bit作分解，使用右位移
// 漸漸將bit取出來，也就是說我們直觀所看到的第一個bit，其實是最後一個取出的，
// 所以使用正迴圈會造成資料倒序，但是我並不是要倒序資料，而是要把放在原本的bit
// 位置，就是陣列第i個元素就應該是，資料的第i個bit，所以就利用反轉迴圈的方式，
// 很順便的將bit丟進陣列裡，我專題作業Bit Plain助教講課時有提過。
//
//	MSB          LSB        	MSB          LSB     bit
//	+---+---+---+---+		  +---+---+---+---+   +---+
//	| 1 | 2 | 3 | 4 | mask =  | 1 | 2 | 3 | 4 | + | 4 | << bit要存到陣列元素4
//	+---+---+---+---+		  +---+---+---+---+   +---+
//
//	當然，你也可以用另外一種方法：就是抓出你要的bit，然後放到指定的陣列元素中 
// ，使用此法的時機，應當是有做了取第n個bit的函數使用。下面即是正回圈的例子：
//	for ( m=0 ; m<4 ; m++) {
//		bit = data & (0x01<<(4-m));
//			// 將遮罩移到你想要的bit上進行AND運算，即取出bit的動作
//		newdat.bit[n/2][m] = bit>>(4-m);
//			// 但是這個bit還需要移到LSB的位置，
//          // 才能存到bit資料堶情A不然資料就不對了。
//	}
//------------------------------------------------------------------------------
dat32perbit sbox (dat48perbit dat, const int S[8][4][16]) {
	dat32perbit	newdat;
	int n, i, m, data, row, col;
	char bit;
	// 8個6轉4
	for ( n=0 ; n<8 ; n++ ) {
		// 取資料作index
		row = ((dat.bit[n][0]<<1) | dat.bit[n][5]);	// 取前後2bit
		for ( i=1, col=0 ; i<5 ; i++ )
			col |= (dat.bit[n][i]<<(4-i));	// 取中間的4位元到col中
		// 將資料逐一分解存到新資料中
		data = S[n][row][col];
		for ( m=3 ; m>=0 ; m-- ) {
			bit = data & 0x01;
			newdat.bit[n/2][m] = bit;
			data>>=1;
		}
	 // 作第二次, 由於48bit的資料寬度=6,以這個資料為依據做出來的結果資料寬度=4
	// 而回傳資料的32bit資料寬度=8, 不過用回圈沒想到可以兩全的方法，
	//	所以就將程式碼寫了兩份，進行資料轉換後並分別存到前後部份。
		n++;
		row = ((dat.bit[n][0]<<1) | dat.bit[n][5]);
		for ( i=1, col=0 ; i<5 ; i++ )
			col |= (dat.bit[n][i]<<(4-i));
		data = S[n][row][col];
		for ( m=7 ; m>=4 ; m-- ) {
			bit = data & 0x01;
			newdat.bit[n/2][m] = bit;
			data>>=1;
		}
	}
	return newdat;
}
//------------------------------------------------------------------------------
//	使用P所提供的新資料所需要的bit編號，然後從dat中將bit取出來放入新資料中。
//	32 bits -> 32 bits
//------------------------------------------------------------------------------
dat32perbit Permutation (dat32perbit dat, const int P[4][8]) {
	dat32perbit newdat;
	int x,y,pos;
	for ( x=0 ; x<8 ; x++ )
		for ( y=0 ; y<4 ; y++ ) {
			pos = P[y][x] - 1;
			newdat.bit[y][x] = dat.bit[pos/8][pos%8];
		}
	return newdat;
}
//------------------------------------------------------------------------------
// 32bits的xor二元運算
//------------------------------------------------------------------------------
dat32perbit xor32bits (dat32perbit dat, dat32perbit ldat) {
	int i;
	for ( i=0 ; i<32 ; i++ )
		dat.bit[i/8][i%8] ^= ldat.bit[i/8][i%8];
	return dat;
}
//------------------------------------------------------------------------------
//	64bits的xor二元運算
//------------------------------------------------------------------------------
dat64perbit xor64bits (dat64perbit dat, dat64perbit ldat) {
	int i;
	for ( i=0 ; i<64 ; i++ )
		dat.bit[i/8][i%8] ^= ldat.bit[i/8][i%8];
	return dat;
}
//------------------------------------------------------------------------------
//	取出64bit資料的其中一半
//------------------------------------------------------------------------------
//	錯誤修正: 等號左右兩邊的index應該不同,原本寫相同的。
//------------------------------------------------------------------------------
dat32perbit dat64parseTo32 (dat64perbit dat,int ctl) {
	dat32perbit newdat;
	int i,b;
	for ( i=(ctl?32:0), b=0 ; i<(ctl?64:32) ; i++,b++)
		newdat.bit[b/8][b%8] = dat.bit[i/8][i%8];
	return newdat;
}
//------------------------------------------------------------------------------
//	兩份32bit資料合成一份64bit資料
//------------------------------------------------------------------------------
dat64perbit Twodat32concat (dat32perbit left, dat32perbit right) {
	dat64perbit	newdat;
	int i,b;
	for ( i=0 ; i<32 ; i++)
		newdat.bit[i/8][i%8] = left.bit[i/8][i%8];
	for ( i=32,b=0 ; i<64 ; i++,b++)
		newdat.bit[i/8][i%8] = right.bit[b/8][b%8];
	return newdat;
}
//------------------------------------------------------------------------------
//	DES 一回合的加密。(最濃縮版=看不懂版=違背設計理念版XD)
//	由於權責區分的關係，所以這個函式正個就是像多個在函式代入而已。
//------------------------------------------------------------------------------
//注意:若是要將這個函式的資料改成使用指標或是參考，必須注意處理參數的順序問題。
//------------------------------------------------------------------------------
dat64perbit des_one_round (dat64perbit dat, key48perbit key) {
	return Twodat32concat(
			dat64parseTo32(dat,1),	// 右半資料成為左半資料
			xor32bits(	// 5作左邊資料與右邊加密資料的xor
				Permutation(	// 4作排列
					sbox(	// 3作非線性的S-Box
						xor48bits(	// 2作資料與key的xor
							ExpansionPermutation(dat,1, E),	// 先作擴充排列
							key),
						Sbox), 
					P),
				dat64parseTo32(dat,0)));
}
//------------------------------------------------------------------------------
//	DES加密，必須事前完成key的產生，才能用這個函式。
//------------------------------------------------------------------------------
//	錯誤修正： DES加密最後需要進行左右32bits的掉換
//------------------------------------------------------------------------------
dat64perbit des_encry (dat64perbit dat,key48perbit key[]) {
	int r;
	dat = InitialPermutation(dat, IP);
	for ( r=0 ; r<16 ; r++)
		dat = des_one_round(dat, key[r]);
	dat = InitialPermutation(Twodat32concat(
		dat64parseTo32(dat,1),dat64parseTo32(dat,0)), IIP);
	return dat;
}
//------------------------------------------------------------------------------
//	DES解碼，程序只需要鑰匙的回合數倒著回去。
//------------------------------------------------------------------------------
//	錯誤修正： DES加密最後需要進行左右32bits的掉換
//	錯誤修正： key的index只有0~15，卻從16開始到數
//------------------------------------------------------------------------------
dat64perbit des_decry (dat64perbit dat,key48perbit key[]) {
	int r;
	dat = InitialPermutation(dat, IP);
	for ( r=15 ; r>=0 ; r-- )
		dat = des_one_round(dat, key[r]);
	dat = InitialPermutation(Twodat32concat(
		dat64parseTo32(dat,1),dat64parseTo32(dat,0)), IIP);
	return dat;
}
//------------------------------------------------------------------------------
//	將無符號型態的char[8](一個byte)轉換成dat64perbit的8*8的bits
//------------------------------------------------------------------------------
dat64perbit uchar8Tobit64 (unsigned char dat[8]) {
	dat64perbit newdat;
	int i,b;
	for ( i=0 ; i<8 ; i++)
		for ( b=7 ; b>=0 ; b--,dat[i]>>=1)
			newdat.bit[i][b] = dat[i] & 0x01;
	return newdat;
}
//------------------------------------------------------------------------------
//	將dat64perbit的資料轉換回char[8],需要一個空間給與這個函式運作
//------------------------------------------------------------------------------
unsigned char* bit64Touchar8 (dat64perbit dat,unsigned char* reval) {
	int i,b;
	if (reval != NULL)
		for ( i=0 ; i<8 ; i++ )
			for( b=0, reval[i]=0 ; b<8 ; b++ )
				reval[i] |= (dat.bit[i][b]<<(7-b));
	return reval;
}
//------------------------------------------------------------------------------
//	key起始的篩選。
//	64 bits -> 56 bits  
//------------------------------------------------------------------------------
//	錯誤修正: array索引與表格資料的差為1
//	錯誤修正: 前後資料寬度不同dat64寬度=8,key56寬度=7
//------------------------------------------------------------------------------
key56perbit PermutedChoiceOne (dat64perbit key, const int PC1[8][7]) {
	key56perbit newdat;
	int x,y;
	for ( x=0 ; x<7 ; x++ ) 
		for ( y=0 ; y<8 ; y++ ) {
			int pos = PC1[y][x]-1;
			newdat.bit[y][x] = key.bit[pos/8][pos%8];
		}
	return newdat;
}
//------------------------------------------------------------------------------
//	每回合轉移過之後的key經過這個函式產生48bits的key，之後再與資料作結合。
//	56 bits -> 48 bits
//------------------------------------------------------------------------------
//	錯誤修正: array索引與表格資料的差為1
//	錯誤修正: 前後資料寬度不同 key48=8,key56=7
//------------------------------------------------------------------------------
key48perbit PermutedChoiceTwo (key56perbit key, const int PC2[6][8]) {
	key48perbit newdat;
	int x,y;
	for ( x=0 ; x<8 ; x++ )
		for ( y=0 ; y<6 ; y++ ) {
			int pos = PC2[y][x]-1;
			newdat.bit[y][x] = key.bit[pos/7][pos%7];
		}
	return newdat;
}
//------------------------------------------------------------------------------
//	產生每回合的48-bits key，這部份可以自己獨立完成，故只寫成一個函式。
//	!!!!!! 注意 !!!!!! 回傳值為動態配置之記憶體位置，必須釋放。
//------------------------------------------------------------------------------
key48perbit* KeyGenerator (unsigned char dkey[8], const int rotate[16]) {
	key56perbit key = PermutedChoiceOne(uchar8Tobit64(dkey),PCO);
	key48perbit *karr = malloc(sizeof(key48perbit)*16);
	int n,r,i;
	for ( n=0 ; n<16 ; n++ ){
		for ( r=0 ; r<rotate[n] ; r++ ){
			char moved;
			int nowmove;
			// 將後面的bit往前移
			for ( i=27 ; i>=0 ; i-- ){
				nowmove = key.bit[i/7][i%7];
				key.bit[i/7][i%7] = moved;
				moved = nowmove;
			}
			key.bit[3][6]= moved;
			// 分左右半部去作
			for ( i=55 ; i>=28 ; i-- ){
				nowmove = key.bit[i/7][i%7];
				key.bit[i/7][i%7] = moved;
				moved = nowmove;
			}
			key.bit[7][6]= moved;
		}
		karr[n] = PermutedChoiceTwo(key,PCT);
	}
	return karr;
}
//------------------------------------------------------------------------------
//	釋放sub-key的記憶體位置
//------------------------------------------------------------------------------
key48perbit* KeyReleaser (key48perbit* tar) {
	free(tar);
	return NULL;
}

#endif
